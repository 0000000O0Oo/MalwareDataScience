import magic, optparse, hashlib, pefile, sys, os
from capstone import *

def getPlatform():
    return os.name

def clearConsole(CurrentOs):
    if CurrentOs == "posix" or CurrentOs == "Linux" or CurrentOs == "linux2":
        os.system("clear")
    elif CurrentOs == "win32" or CurrentOs == "Windows" or CurrentOs == "nt":
        os.system("cls")
    else:
        print("System not found !")

def getFile():
    parser = optparse.OptionParser()
    parser.add_option("-f", "--file", dest="filename", help="Enter the name of the file you want to scan")
    (options, arguments) = parser.parse_args()
    if not options.filename:
        parser.error("Please enter a filename using the -f or --file arguments !")
    else:
        return options.filename

def determineType(file):
    m = magic.Magic(mime=False, uncompress=True if file.endswith('.gz') or file.endswith('.zip') or file.endswith('gzip') or file.endswith('.tar') or file.endswith('.tar.gz') else None)
    ftype = m.from_file(file)
    print("[+] File type : " + ftype)
    return ftype

def getHashValue(file):
    content = open(file, 'rb').read()
    md5hash = hashlib.md5(content).hexdigest()
    sha256hash = hashlib.sha256(content).hexdigest()
    sha1hash = hashlib.sha1(content).hexdigest()
    print("[+] MD5 Hash : " + md5hash)
    print("[+] SHA256 Hash : " + sha256hash)
    print("[+] SHA1 Hash : " + sha1hash)

def getImportTable(file):
    print( "[-]"+ ("-" * 64) + "[-]")
    print("[+] PE Analysis :")
    pe = pefile.PE(file)
    for section in pe.sections:
        print("\t[+] Section", ((section.Name).decode("utf-8")), " : ", hex(section.VirtualAddress), hex(section.Misc_VirtualSize), section.SizeOfRawData)
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        print("[+] Imported DLLs : ", (entry.dll).decode("utf-8"))
        for function in entry.imports:
            print("\t[+]", (function.name).decode("utf-8"))

def getDisassembly(file):
    print( "[-]"+ ("-" * 64) + "[-]")
    print("[+] Basic Disassembly : ")
    PEFile = pefile.PE(file)
    #Get Address of the program entrypoint
    entrypoint = PEFile.OPTIONAL_HEADER.AddressOfEntryPoint
    #Computer memory address where the entry code will be loaded into memory
    entrypoint_address = entrypoint + PEFile.OPTIONAL_HEADER.ImageBase
    #get the binary code from the PE file object
    binary_code = PEFile.get_memory_mapped_image()[entrypoint:entrypoint+100]
    #initialize the disassembler to disassemble 32bit x64 Binary Code
    disassembler = Cs(CS_ARCH_X86, CS_MODE_32)
    #disassemble the code
    for instruction in disassembler.disasm(binary_code, entrypoint_address):
        print("\t[+] {0}\t{1}".format(instruction.mnemonic, instruction.op_str))


CurrentOs = getPlatform()
clearConsole(CurrentOs)
file = getFile()
fileType = determineType(file)
getHashValue(file)

#If the file is a PE32 Executable analyze it else do nothing
if file.endswith(".exe") and "PE" in fileType:
        getImportTable(file)
        getDisassembly(file)
else:
    print("[-] Skipping PE Analysis since the file is not a valid PE file !")
